#JVM整体结构



![image-20200405162151872](./images/image-20200405162151872.png)



![JVM](./images/JVM.png)



#### JVM的架构模型

Java编译器输入指令流是基于**栈的指令集架构**

- 栈式架构：
  + 设计实现简单（出栈入栈），适用于资源受限的系统
  + 避开寄存器分配，使用零地址指令方式分配
  + 指令流中指令大部分是零地址指令（没有地址，只有操作数），执行操作过程依赖于操作栈，指令集小，编译器容易实现
  + 不需要硬件支持（依赖的是内存），可移植性好，更好实现跨平台
- 寄存器架构：
  - 指令集架构依赖硬件，可移植性差
  - 大部分情况，基于寄存器架构指令集都以一地址、二地址、三地址指令为主（有些数可能占用多个地址值）
  - 性能优秀，执行更高效（依赖的是CPU寄存器）
  - 指令更少（寄存器中指令基于16位）



#### JVM的生命周期

- 虚拟机的启动：

  Java虚拟机启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类具体由虚拟机具体实现指定

- 虚拟机的执行：

  执行一个所谓的Java程序的时候，其实是在执行Java虚拟机的进程

- 虚拟机的退出：

  正常结束、异常错误终止、操作系统错误导致Java虚拟机进程终止、调用Runtime或System类的exit，halt方法



####HotSpot虚拟机

- 服务器端、桌面应用、嵌入式等多用途VM
- 通过计数器找到最具编译价值代码，触发即时变异或栈上替换
- 通过编译器与解释器协同工作，在最优化的程序相应时间与最佳执行性能中取得平衡



##类加载器子系统

- 类加载器子系统负责从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识

- ClassLoader只负责Class文件的加载，是否可以运行由Execution Engine决定

- 加载的类信息存放于方法区的内存空间。除了类信息，方法区还会存放运行时常量池信息，可能包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

  

#####类加载器的分类

- JVM支持两种类型的类加载器，**引导类加载器（Boostrap ClassLoader）**和 **自定义加载器（User-Defined ClassLoader）**
- JVM规范定义将所有派生于抽象类ClassLoader的类加载器都划分为自定义加载器



- 引导类加载器
  - 不继承java.lang.ClassLoader，使用C/C++实现，嵌套在JVM内部
  - 加载Java核心库（JAVA_HOME/jre/lib/rt.jar、recouces.jar、sun.boot.class.path路径下的内容）
  - 加载扩展类加载器和系统类加载器，并指定为他们的父类加载器
  - 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
- 扩展类加载器（ExtClassLoader）
  - 派生于ClassLoader类，sun.misc.Launcher$ExtClassLoader实现，父加载器为引导类加载器
  - 从java.ext.dirs系统属性所指定的目录或JDK安装目录的jre/lib/ext子目录下 加载类库（用户创建的jar放在此目录下也会加载）
- 系统类加载器（AppClassLoader）
  - 派生于ClassLoader类，sun.misc.Launcher$AppClassLoader实现，父加载器为引导类加载器
  - 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
  - **系统类加载器是程序中默认的类加载器**，Java应用的类都是由它来完成加载

```
				// 系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();

        // 扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();

        // 引导类加载器
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();

        // 用户自定义类加载器: 默认使用系统类加载器
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();

        // 引导类加载器: Java的核心类库都是使用引导类加载器加载的
        ClassLoader stringClassLoader = String.class.getClassLoader();

```



#####类的加载过程

```mermaid
graph LR
A(Loading) --> B(Verification)
B(Verification) --> C(Preparation)
C(Preparation) --> D(Resolution)
D(Resolution) --> E(Initialization)

```

- Loading:
  1. 通过一个类的全限定名获取定义此类的二进制字节流
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口

- Linking：

  - Verification：
    1. 确保Class文件的字节流符合虚拟机要求
    2. 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证

  - Prepare：

    1. 为类变量（静态变量）分配内存并且设置该类变量的默认初始值

       ```
       private static a = 1; //prepare只会给a一个默认初始化的值0，在initial中才会显式初始化
       ```

    2. **不包括用final修饰的类变量，因为final在编译时就分配了默认值，准备阶段会显式初始化**

       ```
       private static final int a = 1; // final修饰的代表常量，默认初始化在编译的时候就已经完成，prepare会显式初始化
       ```

    3. **不会为实例变量（成员变量）分配初始化**，类变量会分配在方法区中，而实例变量会随着对象一起分配到堆中

  - Resolve:

    1. Resolve操作伴随着JVM在执行完初始化之后再执行

    2. Resolve操作就是将常量池内的符号引用（JVM规范中一组符号来描述所引用的目标）转换为直接引用（直接指向目标的指针、相对偏移量、句柄）的过程

    3. Resolve动作主要针对类或接口、字段、类方法、接口方法、方法类型等

       ```
       CONSTANT_Class_info
       CONSTANT_Fieldref_info
       CONSTANT_Methodref_info
       ...
       ```

- Initialization:

  1. 初始化阶段就是执行类构造器方法<clinit>()的过程，如果一个类没有类变量和静态代码块，则不会有<clinit>()，<clinit>()不同于类的构造器，是由javac编译器自动收集类中的所有**类变量的赋值动作和静态代码块中的语句**合并

     ![image-20200405205305005](./images/image-20200405205305005.png)

  2. 构造器方法<clinit>()中指令按语句在源文件中出现的顺序执行

     ![image-20200405205742215](./images/image-20200405205742215.png)

  3. 若该类具有父类，JVM会先执行父类的<clinit>()

  4. 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁（保证一个类只初始化一次，初始化后放入本地内存->方法区）

##### 用户自定义类加载器

为什么要自定义类加载器？

- 隔离加载类（中间件与应用程序类的冲突）
- 修改类的加载方式（按需加载）
- 扩展加载源（从DB等中获取）
- 防止源码泄漏（解密Class文件）



#### 双亲委派机制

Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class

文件时，Java虚拟机采用的是**双亲委派模式**，即把请求交由给父类处理，它是一种任务委派模式

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行
2. 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试去加载

优势：

1. 避免类的重复加载
2. 保护程序的安全，防止核心的API不会被串改（沙箱安全机制）



## 运行时数据区

运行时数据区（Data Runtime Area）是在内存中操作的一块区域，JVM内部布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM高效稳定运行，不同的JVM对于内存的划分方式和管理机制存在部分差异



![image-20200406142054974](./images/image-20200406142054974.png)



JVM定义了若干种程序运行期间会使用到的运行时数据区，有些随着JVM的生命周期创建销毁，另外一些则是与线程一一对应的

- 线程：程序计数器、栈、本地栈
- 线程共享：堆、堆外内存/方法区（元空间或永久代、代码缓存）



##### Program Counter Register（PC寄存器/程序计数器）

PC寄存器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令

- 生命周期和线程保持一致

- 一个线程任何时间都只有一个**当前方法**在执行，PC寄存器会存储当前线程正在执行的Java方法的JVM指令地址，如果是native方法，则是undefined

- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个寄存器

- 字节码解释器就是改变这个计数器来获取下一条需要执行的字节码指令

- 它是唯一一个JVM中不会发生OOM的区域（没有GC）

  

由于CPU时间片不同，（CPU分配给各个程序的时间）CPU不停的切换各个线程，它必须知道接着从哪继续执行，JVM字节码解释器就必须去改变每个线程的PC寄存器的值来明确下一条指令



####JVM Stacks（虚拟机栈）

设置栈内存 -Xss

JVM栈的生命周期和线程一致，其内部保存的是一个个栈帧（Stack Frame），对应着一次次方法调用，JVM栈主要管理Java程序的运行

它保存方法的局部变量（8种基本数据类型，对象的引用地址）、部分结果，并参与方法的调用和返回

JVM对栈的操作只有两个：每个方法的执行（入栈、压栈），执行结束后的出栈（没有GC）



#####栈帧（Stack Frame）结构：

1. **局部变量表**（Local Variables）

   - 局部变量表被定义为一个数字数组（8种数据类型和引用地址及返回地址都可以用数字来表示），主要用于存储**方法参数和定义在方法体内的局部变量**（各类基本数据类型，对象引用，renturnAddress类型）

   - 局部变量表是建立在线程的栈上，是线程的私有数据，**不存在线程共享数据安全问题**

   - **局部变量表所需的容量大小是在编译期确定下来的**（保存在方法的Code属性的maximum local variables中），方法运行期间不会改变局部变量表的大小

     ![image-20200406201331697](./images/image-20200406201331697.png)

   - 局部变量表**基本的存储单位是Slot**（变量槽）

   - 32位以内的类型只占用一个Slot（引用类型地址值也是32位），64位（long和double）占用2个Slot

   - JVM会为局部变量表种的每一个Slot分配一个访问索引，如果是一个64位局部变量，**使用前一个索引即可访问**

   - **如果当前帧是由构造方法或实例方法（非静态）创建，那么该对象引用this将会存放在index位0的Slot处，其余参数按照顺序继续排列**

     ![image-20200406203216850](./images/image-20200406203216850.png)

     ![image-20200406203243524](./images/image-20200406203243524.png)

   - **栈帧中的局部变量表中的Slot是可以重用的**，如果一个局部变量过了其作用域，在其作用域之后声明的新的局部变量很有可能服用Slot

     ![image-20200406204014281](./images/image-20200406204014281.png)

   - 局部变量表中的变量**在使用前必须赋值，否则编译不通过**

   - *性能调优：在执行方法时，JVM使用局部变量表完成方法的传递，**局部变量表也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被GC回收**

2. **操作数栈**（Operand Stack）（或表达式栈）

   - **在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）**

   - **操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间**

   - 操作数栈是JVM执行引擎的一个工作区，当一个方法开始执行时（创建一个新的栈帧），**这个方法的操作数栈是空的**（虽然是空的，但是这个数组的所需的最大深度在编译期就定义好了，它保存在方法的Code属性中，为max_stack的值）

   - 操作数栈**并非采用访问索引的方式来进行数据访问的**，而是只能通过标准的入栈出栈操作来完成一次数据访问

   - **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新PC寄存器中下一条需要执行的字节码指令

     ![image-20200425203124126](./images/image-20200425203124126.png)

3. 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）

   - 每一个栈帧内部都包含一个**指向运行时常量池中该栈帧所属方法的引用**，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（例如：invokedynamic指令）
   - 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里（例如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，**那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**）
   - 为什么需要常量池？就是为了提供一些符号和常量，便于指令的识别

4. 方法的调用

   - 静态链接（早期绑定【early binding】）：当一个字节码文件被装载进JVM内部时，如果被调用的**目标方法在编译期可知**（非虚方法），且在运行期保持不变，这种情况将调用方法的符号引用转换为直接引用的过程称之为静态链接
     - 非虚方法：方法在编译期确定的方法，包括 静态方法、私有方法、final方法、实例构造器、父类方法
   - 动态链接（晚期绑定【late bingding】）：如果**被调用的方法在编译期无法被确定下来**（虚方法），就是说只能够在程序运行期将调用方法的符号引用转换为直接引用，这种情况被称之为动态链接
     - 虚方法：除了虚方法的其他方法

5. 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）

   - 存放调用该方法的pc寄存器的值
   - 一个方法的结束，有两种方式：
     - 正常执行完成
     - 出现异常，非正常退出
   - 无论哪种方式退出，都会回到该方法被调用的位置，**方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址**。异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息

6. 一些附加信息



#### 本地方法栈（Native Method Stack）

- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用（使用C语言实现）
- 本地方法栈也是线程私有的
- 允许被实现成固定或者是可动态扩展的内存大小
- 它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库
- 当线程调用本地方法时，它不再受虚拟机限制，它和虚拟机拥有相同的权限
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  - 它甚至可以直接使用本地处理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存
- JVM虚拟机规范没有明确要求本地方法栈的实现语言，所以并不是所有JVM虚拟机都支持本地方法



#### 堆（Heap）

- 一个JVM实例只存在一个堆内存

- Java堆在JVM启动时即被创建，其大小空间也就确定了，堆内存的大小可以通过启动参数调节

- JVM虚拟机规范规定，堆可以处于**物理上不连续**的内存空间中，但在逻辑上应被视为连续的

- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）

- 所有（几乎）对象实例以及数组都应当在运行时分配在堆上

- 数组和对象**可能**永远不会存储在栈上，因为栈帧保存引用，这个引用指向对象或者数组在堆中的位置

- 在方法结束后，堆中对戏那个不会马上被移除，仅仅在垃圾手机的时候才会被移除

- 堆，是GC执行垃圾回收的重点区域

  

##### 堆的内存细分

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

- Java 7及之前内存逻辑上分为三部分：新生代，老年代，**永久代**
  - Young Generation Space
    - Eden
    - Survivor
  - Tenure Generation Space
  - Permanent Space
- Java 8及之后堆内存逻辑上分为三部分：新生代，老年代，**元空间**
  - Young Generation Space
    - Eden
    - Survivor
  - Tenure Generation Space
  - Meta Space



##### 堆空间的大小设置

1.手动设置堆空间大小，通常情况下会将-Xms 和 -Xmx两个参数配置相同的值，**目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能**

- -Xms：用于表示堆区的初始内存大小，等价于-XX：InitialHeapSize
  - -X 是JVM的运行参数
  - ms是memory start
- -Xmx：用于表示堆区最大内存大小，等价于-XX：MaxHeapSize

2.默认情况下

- 初始内存大小：物理内存大小 / 64
- 最大内存大小：物理内存带下 / 4

3.查看设置参数：

- jps / jstat -gc 进程id
- -XX:+printGCDetails



#####年轻代与老年代

